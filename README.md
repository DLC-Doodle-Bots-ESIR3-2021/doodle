# Software bots in Software Engineering

Software bots are simple or complex computer programs designed to do specific actions, such as automating repetitive tasks or simulating human users, among others.

In this pull request we had the opportunity to manipulate different bots. In a first part we will show you how to use dependabot. Dependabot is a bot integrated in github, in charge of managing the updates of the project dependencies. 
<br>Then in a second part we will show you how to create a bot. This new bot will automatically merge the pull request if 2 reviewers approve the pull request.

## Dependabot and Continious Integration (C.I)
### Dependabot

Dependabot automatically raise pull requests to keep your dependencies up-to-date. This helps reduce your exposure to older versions of dependencies. Using newer versions makes it easier to apply patches if security vulnerabilities are discovered, and also makes it easier for Dependabot security updates to successfully raise pull requests to upgrade vulnerable dependencies. 

In order to install the Dependabot, you have to go through the repository settings:
![image](https://user-images.githubusercontent.com/24569493/143913942-76591e02-8fd4-467c-8bfd-98a5b92b8b84.png)

After that you will have to create a folder at the root of the repository named ".github" which should contain the bot configuration file "dependabot.yml", this file should look like this one:

```
# Basic dependabot.yml file with
# minimum configuration for two package managers

version: 2
updates:
  # Enable version updates for npm
  - package-ecosystem: "npm"
    # Look for `package.json` and `lock` files in the `root` directory
    directory: "/front"
    # Check the npm registry for updates every day (weekdays)
    schedule:
      interval: "daily"
    open-pull-requests-limit: 1000 #Add a limit for number of pull request to 1000 (0 will disable this module)
    milestone: 1 #Add a group for pull request
    target-branch: "develop" #target branch to check update of dependencies et pull request on this branch
    labels:
      - "javascript"
      - "dependencies"
      - "dependabot"

    # Enable version updates for Docker
  - package-ecosystem: "maven"
    # Look for a `Dockerfile` in the `root` directory
    directory: "/api"
    # Check for updates once a week
    schedule:
      interval: "daily"
    open-pull-requests-limit: 1000 #Add a limit for number of pull request to 1000 (0 will disable this module)
    milestone: 2 #Add a group for pull request
    target-branch: "develop" #target branch to check update of dependencies et pull request on this branch
    labels:
      - "java"
      - "dependencies"
      - "dependabot"
```

It should contain a "package-ecosystem" tag per project to be included in the dependency updates. Under this tag will be present a directory tag in order to indicate the path to the project to update continuously. For all the details of the configuration tags: https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates

### Continious Integration (C.I) 

To perform continious integration on github we use GitHub Action. Github Action helps you automate tasks within your software development life cycle. GitHub Actions are event-driven, meaning that you can run a series of commands after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command that executes a software testing script. 
<br> In our case each pull request generated by dependabot will trigger an action. This action verifies that the project is still building despite the evolution added by dependabot. If the project is still building we will asked to the dependabot to merge the pull request into our target branch.

#### Creation GitHub Action

To create a GitHub Action we create a file `.yml` named as our GitHub Action in the directory `.github/workflows/`

The architecture of a GitHub Action file is as follows: 
```
name: Angular Building Checker

# Controls when the workflow will run
on: [workflow_dispatch, pull_request]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      - name: Display label
        run: echo ${{ github.event.pull_request.labels.*.name }}
```
`on : workflow_dispatch`  enable the ability to lanch the action manually. otherwise the action will be automatically trigger by the other event listed.

By default the jobs run in parallel. If you want to run job sequentially you need to specify wich job should procede it.
For exemple if you need a job `job2` that run after job `build`. You need to add the key word `needs` in the specification of the job `job2` as follow :

```
...

jobs:
  # This workflow contains a single job called "build"
  build:
    
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    ...
    
  job2:
    needs: build
     The type of runner that the job will run on
    runs-on: ubuntu-latest
    ...
```

### GitHub Action :  BuildAction

The [action](.github/workflows/BuildAction.yml) we have done is intended to be triggered at each pull request made by dependabot. It will check if the project is still building and will automatically merge the pull request if it is the case.

To perform this action we have created 2 jobs that will run sequentially. 

#### Job : build

The role of the first job `build` is to check if the project is still building.

```yml
...
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    if: contains(github.event.pull_request.labels.*.name, 'dependabot')
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
        
      - name: npm install
        if: contains(github.event.pull_request.labels.*.name, 'javascript')
        working-directory: ./front
        run: npm install
        
      - name: npm run build
        if: contains(github.event.pull_request.labels.*.name, 'javascript')
        working-directory: ./front
        run: npm run build
        
      - name: Maven Install
        if: contains(github.event.pull_request.labels.*.name, 'java')
        working-directory: ./api
        run: mvn install
        
      - name: Maven Build
        if: contains(github.event.pull_request.labels.*.name, 'java')
        working-directory: ./api
        run: mvn compile
...
```
In order to build only the project concern by the update we take a look to the labels of the project. If the labels contain `java` we perform the maven build in the right directory. Otherwise we check if the labels contain `javascript` to perform the nodeJs build.

To check the label we use the key word `if` with the combination of the fonction `contains`.

```yml
- name: npm install
        if: contains(github.event.pull_request.labels.*.name, 'javascript')
        working-directory: ./front
        run: npm install
```

#### Job : merge

The role of the second job `merge` is to merge the branch if the job `build` is a succes.

To perform a merge we decide to use an action enable in the market place of GitHub. This action enable us to merge the pull request. We just need the number of the pull request. 

```yml
...
merge:
    needs: build
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.labels.*.name, 'dependabot')
    steps:
    - name: Display the PR number
      run: echo ${{ github.event.number }}
    
    - name: merge-pr
      # You may pin to the exact commit or the version.
      # uses: nbrugger-tgm/merge-pr-action@80dca9937195f2bb2413eb693fe25614fadb0385
      uses: nbrugger-tgm/merge-pr-action@v0.2.2
      with:
        # github token
        token: ${{ secrets.GITHUB_TOKEN }}
        # merge method (squash, merge or rebase)
        # pull request number to merge
        pull_request: ${{ github.event.number }}
```

## Development of a Github bot with Probot

This second part will describe how to build a Github bot quickly using Probot and the Github APIs.
As an example, the bot we created anterior to the tutorial is [available here](https://github.com/apps/probot-approved-pr).

### Starting template

To start developping a Github bot, you first need a dedicated repository hosting the bot's code.
With the command `npx create-probot-app my-custom-bot` you will be allowed to setup a basic "Hello World" bot following an interactive setup menu from the terminal.

The simplest way to develop a Probot bot is to choose the `basic-ts` template as a basis to build the bot, which prevents us from meeting several issues we may encounter if we chose a JavaScript-based template instead.

After creating a basis for the bot, you will have to register the Github bot as an App on Github by starting the bot running `npm start` and visiting the [localhost](http://localhost:3000). At the end of this process you will have the opportunity to add your bot to one of the repositories you have access to. This action can still be performed afterwards when you go on [https://github.com/apps/my-custom-bot](https://github.com/apps/probot-approved-pr) and click on the **Configure** button.

### Required settings

#### On the Github App page

When the bot is created with the basic template and is registered, the next step is to set the settings so that they can match your repository's url, the Webhook url and enabling permissions on the necessary Github elements to read and write data. From the [Github app url](https://github.com/apps/probot-approved-pr), click on **App settings**.

There you can find the APP ID of your app, the Client ID and you can generate a Client Secret Key to link your running code (in your local machine or on a working remote VM) to the Github App. The Client ID and Client Secret Key may be necessary only if you use some specific proxy webhook forwarders (like [Smee.io](https://smee.io/)).
In other words, this secret key and the ID are used to authenticate **Smee.io** as your bot from Github's perspective for delivering Github events.

Below you can see and change your bot name and description.
Then you can setup the **Homepage url** to be the location of your repository hosting the code of your bot.

The next relevant section is **Webhook** which is mandatory for us to receive informations when a Github event is triggered on the repositories the bot has access to. If the **Webhook url** isn't already defined and you don't have an open IP address to access to the forwarded Github events, you can go on [smee.io](https://smee.io/) and **Start a new channel**, copy the url and secret given by Smee.io. It will intercept the Github events triggered and forward them to your bot, it will play the role of a proxy server. In any cases, you must generate and copy a new **Webhook Secret** that will be used to allow your bot to have access to the triggered Github events.

You must generate a new **Private Key** from the Github App settings page in order to fully allow your source code to be seen as the running instance of the Github App. 

Finally, the most crucial settings for your bot is the access to Github data from the Github repositories using it. In the **Permissions & events** tab, you can select each permission your bot needs. It always needs access to **Metadata** and in our case, it also needs access to **Pull requests** and **Content** in both **Read** and **Write** in order to read informations about pull requests and trigger a merge. Once you save the changes in permissions, the owners of the repositories where the bot is installed will be notified and have to approve or not the new permissions, if not, the bot is simply removed from the repository.

#### In the source code

In your Probot bot repository, you can now in your generated [.env](https://github.com/DLC-Doodle-Bots-ESIR3-2021/probot-semantic-pr/blob/master/.env.example) file add the `APP_ID`, `GITHUB_CLIENT_ID`, `GITHUB_CLIENT_SECRET` and `WEBHOOK_SECRET` variables based on the settings of your Github App. If you use **Smee.io** as a proxy server for the Webhooks, add the `WEBHOOK_PROXY_URL` variable with the Webhook url you got from [smee.io](https://smee.io/). You will then have to install the **smee client** to have a working pipeline from [smee.io](https://smee.io/) to the running instance of your bot, as following: `npm i --save smee-client`.

Matching the permissions you required from your Github App, you have to go on the [app.yml](https://github.com/DLC-Doodle-Bots-ESIR3-2021/probot-semantic-pr/blob/master/app.yml) file and uncomment the lines refering to the events you want to observe, also uncomment the permissions you requested on the Github App **Permissions & events** settings page to match the access rights required (pay attention to the difference between **read** and **write**).

### Development of the bot

The bot in itself is quite simple because the use of Github's GraphQL API eased a lot the process of fetching pertinent pieces of information and performing actions on the repositories.

The `app.on(events, function)` scope defines which events to listen to and which function to execute when the designated events are triggered. A bot can have several `app.on(...)` scopes if you need to perform different actions depending on the event triggered.
In our case, only the `pull_request_review.submitted` event is relevant.

From each event, the Github Webhook will return a valuable information which is the `context`, argument of the function launched when the event is triggered. From the `context` we can either read information with `context.payload` or act on the repository with `context.octokit`.

Our bot first reads (`payload`) the pull request **number** and **node_id** to identify it, then we use these pieces of information to make some authenticated requests to Github using the `context.octokit.graphql` method to perform complex API requests. The first one fetches the pull request's count of currently approved reviews and if the pull request has already been merged or not (based on the pull request's `number`). The second GraphQL call triggers a merge action on the pull request (identified this time by its `node_id`) if the branch hasn't already been merged and if the current number of approved reviews is at least 2.

#### Authentication

Because the GraphQL requests made by the bot need an authentication, it is needed to identify the bot as the author of those requests. In order to do that, 2 main methods are available. One is to authenticate it as an App with the `APP_ID` and `PRIVATE_KEY` previously registered in the `.env` file, while the other method is to register the bot as an Installation which requires an InstallationId in addition to the `APP_ID` and `PRIVATE_KEY`. The latest will be used because the bot is used to perform API calls and modify the repositories where it is installed. The App authentication is mostly used to retrieve information and statistics. Note that the generated token is time-limited.

For that we fetch the InstallationId of the bot, this piece of information is contained inside the `payload` Object of the `context`. The authentication token is then retrieved by authenticating the bot as an installation using the `auth` method of the `context.octokit` Object.
Here is how it has been done for [this bot](https://github.com/DLC-Doodle-Bots-ESIR3-2021/probot-semantic-pr/) :
```TypeScript
const installationId = context.payload.installation?.id

// Retrieve installation access token
const installationAuthentication = await context.octokit.auth({
  type: "installation",
  installationId: installationId,
}) as InstallationAccessTokenAuthentication;
const token = installationAuthentication.token;
```

### How to make it run

Simply compile the TypeScript code by running `npm run build` and then launch the bot's server by running `npm run start`. That's it! Your bot is now running and catching Github events, processing on the received events it looks for and consuming Github GraphQL API.